[[ stl ]]

// string.tea
//
// MIT License
//
// Copyright (c) 2021-2022 Ferhat GeÃ§doÄŸan All Rights Reserved.
// Distributed under the terms of the MIT License.
//
//

import tea.green.type
import tea.green.char
import tea.black.vector

include [[ "<sstream>" ]]

`set __empty__char__ = '\0'
`set __newline__     = '\n'

compile default for cstring { "" }

module cpp_str {
    fn cpp_str#append(&data: cstring, what: cstring) {
        [[ unsafe ]] {
            data.append(what)
        }
    }

    fn cpp_str#append(&data: cstring, what: cstring, pos: int64, len: uint64) {
        [[ unsafe ]] {
            data.append(what, pos, len)
        }
    }

    fn cpp_str#append(&data: cstring, n: int64, ch: char) {
        [[ unsafe ]] {
            data.append(n, ch)
        }
    }

    fn cpp_str#assign(&data: cstring, what: cstring) {
        [[ unsafe ]] {
            data.assign(what)
        }
    }

    fn cpp_str#assign(&data: cstring, what: cstring, pos: int64, len: uint64) {
        [[ unsafe ]] {
            data.assign(what, pos, len)
        }
    }

    fn cpp_str#assign(&data: cstring, n: int64, ch: char) {
        [[ unsafe ]] {
            data.assign(n, ch)
        }
    }

    fn cpp_str#at(data: cstring, n: uint64) = char {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.at(n);
            }
        }
    }

    fn cpp_str#back(data: cstring) = char {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.back();
            }
        }
    }

    fn cpp_str#capacity(data: cstring) = uint64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.capacity();
            }
        }
    }

    fn cpp_str#erase(&data: cstring) {
        [[ unsafe ]] {
            data.erase()
        }
    }

    fn cpp_str#compare(data: cstring, &compare: cstring) = int8 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.compare(compare);
            }
        }
    }

    fn cpp_str#empty(data: cstring) = bool {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.empty();
            }
        }
    }

    fn cpp_str#erase(data: cstring, pos: uint64, len: int64) = cstring {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.erase(pos, len);
            }
        }
    }

    fn cpp_str#find(data: cstring, &what: cstring, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find(what, pos);
            }
        }
    }

    fn cpp_str#find(data: cstring, ch: char, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find(ch, pos);
            }
        }
    }

    fn cpp_str#find_first_not_of(data: cstring, &what: cstring, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find_first_not_of(what, pos);
            }
        }
    }

    fn cpp_str#find_first_not_of(data: cstring, ch: char, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find_first_not_of(ch, pos);
            }
        }
    }

    fn cpp_str#find_first_of(data: cstring, &what: cstring, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find_first_of(what, pos);
            }
        }
    }

    fn cpp_str#find_first_of(data: cstring, ch: char, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find_first_of(ch, pos);
            }
        }
    }

    fn cpp_str#find_last_not_of(data: cstring, &what: cstring, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find_last_not_of(what, pos);
            }
        }
    }

    fn cpp_str#find_last_not_of(data: cstring, ch: char, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find_last_not_of(ch, pos);
            }
        }
    }

    fn cpp_str#find_last_of(data: cstring, &what: cstring, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find_last_of(what, pos);
            }
        }
    }

    fn cpp_str#find_last_of(data: cstring, ch: char, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.find_last_of(ch, pos);
            }
        }
    }

    fn cpp_str#front(data: cstring) = char {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.front();
            }
        }
    }

    fn cpp_str#insert(data: cstring, pos: int64, &what: cstring) = cstring {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.insert(pos, what);
            }
        }
    }

    fn cpp_str#length(data: cstring) = uint64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.length();
            }
        }
    }

    fn cpp_str#max_size(data: cstring) = uint64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.max_size();
            }
        }
    }

    fn cpp_str#pop_back(&data: cstring) {
        [[ unsafe ]] {
            data.pop_back()
        }
    }

    fn cpp_str#push_back(&data: cstring, ch: char) {
        [[ unsafe ]] {
            data.push_back(ch)
        }
    }

    fn cpp_str#replace(data: cstring, &what: cstring, pos: int64, len: uint64) = cstring {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.replace(pos, len, what);
            }
        }
    }

    fn cpp_str#reserve(&data: cstring, n: int64) {
        [[ unsafe ]] {
            data.reserve(n)
        }
    }

    fn cpp_str#resize(&data: cstring, n: int64) {
        [[ unsafe ]] {
            data.resize(n)
        }
    }

    fn cpp_str#resize(&data: cstring, n: int64, ch: char) {
        [[ unsafe ]] {
            data.resize(n, ch)
        }
    }

    fn cpp_str#rfind(data: cstring, &what: cstring, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.rfind(what, pos);
            }
        }
    }

    fn cpp_str#rfind(data: cstring, ch: char, pos: uint64) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.rfind(ch, pos);
            }
        }
    }

    fn cpp_str#shrink_to_fit(&data: cstring) {
        [[ unsafe ]] {
            data.shrink_to_fit()
        }
    }

    fn cpp_str#size(&data: cstring) = int64 {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.size();
            }
        }
    }

    fn cpp_str#substr(data: cstring, pos: int64, len: int64) = cstring {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.substr(pos, len);
            }
        }
    }

    fn cpp_str#swap(&data: cstring, what: cstring) {
        [[ unsafe ]] {
            data.swap(what)
        }
    }

    fn cpp_str#to_string<Arg>(data: Arg) = cstring {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    std::to_string(data);
            }
        }
    }

    fn cpp_str#c_str(data: cstring) = char* {
        [[ unsafe ]] {
            [[ cpp ]] {
                return \
                    data.data();
            }
        }
    }
}

module str {
    fn str#first(data: cstring) = char {
        var mut __first: int64 = 0

        for &ch in data {
            . ch
        } . (char)__first
    }

    fn str#last(data: cstring) = char {
        var mut __last: int64 = 0

        for &ch in data {
            [[ unsafe ]] {
                __last = ch
            }
        } . (char)__last
    }

    fn str#upper(data: cstring) = cstring {
        var mut val: cstring = ""

        for &ch in data {
            cpp_str#push_back(val, ch#upper(ch))
        } . val
    }

    fn str#lower(data: cstring) = cstring {
        var mut val: cstring = ""

        for &ch in data {
            cpp_str#push_back(val, ch#lower(ch))
        } . val
    }

    fn str#append(data: cstring, what: cstring) = cstring {
        cpp_str#append(data, what)

        . data
    }

    fn str#capitalize(data: cstring) = cstring {
        var mut __data: cstring = ""
        var mut first : bool   = false

        for &ch in data {
            if first {
                cpp_str#push_back(__data, ch#lower(ch))
            }
            else {
                cpp_str#push_back(__data, ch#upper(ch))

                [[ unsafe ]] {
                    first = true
                }
            }
        } . __data
    }

    fn str#is_empty(data: cstring) = bool {
        if cpp_str#length(data) == 0 {
            . true
        } . false
    }

    fn str#split(data: cstring, delim: char) = []cstring {
        var mut __data: []cstring = [[ unsafe ]]
        var mut temp: cstring = ""

        for &ch in data {
            if ch == delim && !str#is_empty(temp) {
                cpp_vector#push_back(__data, temp)
                cpp_str#erase(temp)

                continue
            }

            cpp_str#push_back(temp, ch)
        }

        cpp_vector#push_back(__data, temp)

        . __data
    }

    fn str#splitlines(data: cstring) = []cstring {
        var mut __data: []cstring = [[ unsafe ]]

        __data = str#split(data, __newline__);

        . __data
    }
} // str